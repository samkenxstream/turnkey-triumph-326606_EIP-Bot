{"version":3,"file":"Types.js","sourceRoot":"","sources":["../../../src/domain/Types.ts"],"names":[],"mappings":";;;AAIA,sDAAsD;AAyHzC,QAAA,SAAS,GAAG;IACvB,OAAO;IACP,MAAM;IACN,OAAO;IACP,SAAS;IACT,MAAM;IACN,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,KAAK;CACG,CAAC;AAQX,IAAY,WAKX;AALD,WAAY,WAAW;IACrB,0BAAW,CAAA;IACX,4BAAa,CAAA;IACb,8BAAe,CAAA;IACf,0BAAW,CAAA;AACb,CAAC,EALW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAKtB;AAaD,IAAY,QAKX;AALD,WAAY,QAAQ;IAClB,yBAAa,CAAA;IACb,yBAAa,CAAA;IACb,uCAA2B,CAAA;IAC3B,qCAAyB,CAAA;AAC3B,CAAC,EALW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAKnB;AAED,SAAgB,iBAAiB,CAAC,MAAM;IACtC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QAChD,MAAM,IAAI,0BAAa,CAAC,UAAU,MAAM,iCAAiC,CAAC,CAAC;KAC5E;SAAM;QACL,OAAO,MAAM,CAAC;KACf;AACH,CAAC;AAND,8CAMC","sourcesContent":["import { getOctokit } from \"@actions/github\";\nimport { ChangeTypes, EIPCategory, EipStatus, EIPTypes } from \"./Constants\";\nimport { FrontMatterResult } from \"front-matter\";\nimport { PromiseValue } from \"type-fest\";\nimport { CriticalError } from \"src/domain/exceptions\";\n\nexport type Github = ReturnType<typeof getOctokit>[\"rest\"];\n\ntype UnArrayify<T> = T extends (infer U)[] ? U : T;\n\nexport type CompareCommits = PromiseValue<\n  ReturnType<Github[\"repos\"][\"compareCommits\"]>\n>[\"data\"];\nexport type PR = PromiseValue<ReturnType<Github[\"pulls\"][\"get\"]>>[\"data\"];\nexport type Commit = PromiseValue<\n  ReturnType<Github[\"repos\"][\"getCommit\"]>\n>[\"data\"];\nexport type Files = PromiseValue<\n  ReturnType<Github[\"pulls\"][\"listFiles\"]>\n>[\"data\"];\nexport type File = Files[number];\nexport type CommitFiles = CompareCommits[\"base_commit\"][\"files\"];\nexport type CommitFile = UnArrayify<NonNullable<CommitFiles>>;\nexport type Repo = PromiseValue<ReturnType<Github[\"repos\"][\"get\"]>>[\"data\"];\nexport type GithubSelf = PromiseValue<\n  ReturnType<Github[\"users\"][\"getAuthenticated\"]>\n>[\"data\"];\nexport type IssueComments = PromiseValue<\n  ReturnType<Github[\"issues\"][\"listComments\"]>\n>[\"data\"];\nexport type Review = PromiseValue<ReturnType<Github[\"pulls\"][\"listReviews\"]>>[\"data\"][number]\n\n// This was extracted directly from Octokit repo\n// node_modules/@octokit/openapi-types/generated/types.ts : 7513 - 7553\nexport type ContentFile = {\n  type: string;\n  encoding: string;\n  size: number;\n  name: string;\n  path: string;\n  content: string;\n  sha: string;\n  url: string;\n  git_url: string | null;\n  html_url: string | null;\n  download_url: string | null;\n  _links: {\n    git: string | null;\n    html: string | null;\n    self: string;\n  };\n  target?: string;\n  submodule_git_url?: string;\n};\n\nexport type ContentData = PromiseValue<\n  ReturnType<Github[\"repos\"][\"getContent\"]>\n>[\"data\"];\n\nexport type EIP = {\n  number: string;\n  status: EipStatus;\n  authors: Set<string>;\n};\n\nexport type FormattedFile = {\n  eipNum: number;\n  status: EipStatus;\n  authors?: Set<string>;\n  name: string;\n  filenameEipNum: number;\n  category: Maybe<EIPCategory>;\n  type: EIPTypes;\n};\n\nexport type Maybe<T> = T | null;\n\nexport type ParsedContent = {\n  path: string;\n  name: string;\n  content: FrontMatterResult<any>;\n};\n\nexport type FileDiff = {\n  head: FormattedFile;\n  base: FormattedFile;\n};\n\nexport type ERRORS = {\n  fileErrors: {\n    filePreexistingError?: string;\n    validFilenameError?: string;\n  };\n  headerErrors: {\n    matchingEIPNumError?: string;\n    constantEIPNumError?: string;\n    constantStatusError?: string;\n    validStatusError?: string;\n  };\n  authorErrors: {\n    hasAuthorsError?: string;\n  };\n  approvalErrors: {\n    isAuthorApprovedError?: string;\n    isEditorApprovedError?: string;\n    enoughEditorApprovalsForEIP1Error?: string;\n  };\n};\n\ntype LeafsToBoolean<O> = {\n  [K in keyof O]: O[K] extends Record<any, any>\n    ? Required<LeafsToBoolean<O[K]>>\n    : boolean | null;\n};\n\n/**\n * this type is used to define filter definitions for different change types; the\n * type of a change should be distinguishable by the errors alone. Each leaf\n * can be either true, false, or null where\n * - true: an error exists for this leaf\n * - false: an error does not exist for this leaf\n * - null: either\n * */\nexport type ERRORS_TYPE_FILTER = LeafsToBoolean<ERRORS>;\n\nexport const encodings = [\n  \"ascii\",\n  \"utf8\",\n  \"utf-8\",\n  \"utf16le\",\n  \"ucs2\",\n  \"ucs-2\",\n  \"base64\",\n  \"latin1\",\n  \"binary\",\n  \"hex\"\n] as const;\nexport type Encodings = typeof encodings[number];\n\nexport type TestResults = { errors: ERRORS } & {\n  fileDiff: FileDiff;\n  authors?: string[];\n};\n\nexport enum MockMethods {\n  get = \"GET\",\n  post = \"POST\",\n  patch = \"PATCH\",\n  put = \"PUT\"\n}\n\nexport type MockRecord = {\n  req: {\n    method: string; // ValueOf<{ [k in keyof typeof MockMethods]: `${typeof MockMethods[k]}` }>;\n    url: string;\n  };\n  res: {\n    status: number;\n    data: any;\n  };\n};\n\nexport enum NodeEnvs {\n  test = \"test\",\n  mock = \"MOCK\",\n  developemnt = \"development\",\n  production = \"production\"\n}\n\nexport function requireMockMethod(method): asserts method is MockMethods {\n  if (!Object.values(MockMethods).includes(method)) {\n    throw new CriticalError(`method ${method} is not a supported mock method`);\n  } else {\n    return method;\n  }\n}\n\nexport type Result = {\n  filename: string;\n  successMessage?: string;\n  errors?: string[];\n  mentions?: string[];\n  type: ChangeTypes;\n};\n\nexport type Results = Result[];\n\nexport type PropsValue<T extends (...args: any[]) => any> = T extends (\n  ...args: infer Props\n) => any\n  ? Props\n  : never;\n\nexport type MockedFunctionObject<\n  Obj extends Record<string, (...args: any[]) => any>\n> = { [key in keyof Obj]?: jest.MockedFunction<Obj[key]> };\n"]}