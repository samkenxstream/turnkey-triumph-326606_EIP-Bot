{"version":3,"file":"assert_eip1_editor_approvals.js","sourceRoot":"","sources":["../../../../src/modules/assertions/assert_eip1_editor_approvals.ts"],"names":[],"mappings":";;;AAAA,6CAAiD;AACjD,uCAAsE;AACtE,mCAA0C;AAG1C,MAAa,yBAAyB;IACpC,YAAmB,YAAqC;QAArC,iBAAY,GAAZ,YAAY,CAAyB;QAExD,8BAAyB,GAAG,KAAK,EAAE,QAAkB,EAAE,EAAE;YACvD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;YAE5C,MAAM,OAAO,GAAG,IAAA,8BAAiB,EAAC,QAAQ,CAAC,CAAC;YAC5C,MAAM,eAAe,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,EAAE,CACpD,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAC3B,CAAC;YACF,IAAI,eAAe,CAAC,MAAM,GAAG,uCAA8B,EAAE;gBAC3D,OAAO,IAAA,uBAAe,EAAC,GAAG,CAAC,CACzB,qCAAqC,uCAA8B,EAAE,EACrE,oDAAoD,eAAe,CAAC,MAAM,aAAa,EACvF,6BAA6B,OAAO;qBACjC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;qBACrD,IAAI,CAAC,IAAI,CAAC,EAAE,CAChB,CAAC;aACH;;gBAAM,OAAO;QAChB,CAAC,CAAC;IAlByD,CAAC;CAmB7D;AApBD,8DAoBC","sourcesContent":["import { requireEIPEditors } from \"#/assertions\";\nimport { EIP1_REQUIRED_EDITOR_APPROVALS, FileDiff } from \"src/domain\";\nimport { multiLineString } from \"#/utils\";\nimport { IAssertEIP1EditorApprovals } from \"#/assertions/Domain/types\";\n\nexport class AssertEIP1EditorApprovals implements IAssertEIP1EditorApprovals {\n  constructor(public getApprovals: () => Promise<string[]>) {}\n\n  assertEIP1EditorApprovals = async (fileDiff: FileDiff) => {\n    const approvals = await this.getApprovals();\n\n    const editors = requireEIPEditors(fileDiff);\n    const editorApprovals = approvals.filter((approver) =>\n      editors.includes(approver)\n    );\n    if (editorApprovals.length < EIP1_REQUIRED_EDITOR_APPROVALS) {\n      return multiLineString(\" \")(\n        `Changes to EIP 1 require at least ${EIP1_REQUIRED_EDITOR_APPROVALS}`,\n        `unique approvals from editors; there's currently ${editorApprovals.length} approvals;`,\n        `the remaining editors are ${editors\n          .filter((editor) => !editorApprovals.includes(editor))\n          .join(\", \")}`\n      );\n    } else return;\n  };\n}\n"]}