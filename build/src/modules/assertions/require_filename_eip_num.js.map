{"version":3,"file":"require_filename_eip_num.js","sourceRoot":"","sources":["../../../../src/modules/assertions/require_filename_eip_num.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ASSETS_EIP_NUM,\n  EIP_NUM_RE,\n  File,\n  FILE_IN_EIP_FOLDER,\n  FileDiff,\n  isFileNotFound,\n  ParsedContent,\n  PR\n} from \"src/domain\";\nimport {\n  GracefulTermination,\n  RequirementViolation,\n  UnexpectedError\n} from \"src/domain/exceptions\";\nimport { IRequireFilenameEIPNum } from \"#/assertions/Domain/types\";\nimport { multiLineString } from \"../utils\";\nimport _ from \"lodash\";\n\nexport class RequireFilenameEIPNum implements IRequireFilenameEIPNum {\n  public getPullRequestFiles: (pullNumber: number) => Promise<File[]>;\n  public requirePr: () => Promise<PR>;\n  public requireEIPEditors: (fileDiff?: FileDiff | undefined) => string[];\n  public getApprovals: () => Promise<string[]>;\n  public getParsedContent: (\n    filename: string,\n    sha: string\n  ) => Promise<ParsedContent>;\n\n  constructor({\n    getPullRequestFiles,\n    requirePr,\n    requireEIPEditors,\n    getApprovals,\n    getParsedContent\n  }: {\n    getPullRequestFiles: (pullNumber: number) => Promise<File[]>;\n    requirePr: () => Promise<PR>;\n    requireEIPEditors: (fileDiff?: FileDiff | undefined) => string[];\n    getApprovals: () => Promise<string[]>;\n    getParsedContent: (filename: string, sha: string) => Promise<ParsedContent>;\n  }) {\n    this.getPullRequestFiles = getPullRequestFiles;\n    this.requirePr = requirePr;\n    this.requireEIPEditors = requireEIPEditors;\n    this.getApprovals = getApprovals;\n    this.getParsedContent = getParsedContent;\n  }\n\n  public attemptAssetGracefulTermination = async (path: string) => {\n    if (!ASSETS_EIP_NUM.test(path)) {\n      return;\n    }\n\n    const assetEipNumMatch = path.match(ASSETS_EIP_NUM);\n    if (!assetEipNumMatch || assetEipNumMatch[1] === undefined) {\n      throw new UnexpectedError(\n        multiLineString(\" \")(\n          `The filename '${path}' is seen to match an asset file but`,\n          `the extracted eip number is undefined`\n        )\n      );\n    }\n    const assetEipNum = parseInt(assetEipNumMatch[1]);\n    const pr = await this.requirePr();\n    const files = await this.getPullRequestFiles(pr.number);\n\n    const filenames = files.map((file) => file.filename);\n\n    for (const otherFilename of filenames) {\n      // if other filename is same as current one then skip\n      if (otherFilename === path) {\n        continue;\n      }\n\n      // if the filename doesn't match to an eip number skip\n      const eipNumMatch = otherFilename.match(EIP_NUM_RE);\n      if (!eipNumMatch || eipNumMatch[1] === undefined) {\n        continue;\n      }\n\n      const eipNum = parseInt(eipNumMatch[1]);\n      if (eipNum === assetEipNum) {\n        throw new GracefulTermination(\n          multiLineString(\" \")(\n            `file ${path} is associated with EIP ${assetEipNum}; because`,\n            `there are also changes being made to ${otherFilename} all changes`,\n            `to corresponding assets are also allowed`\n          )\n        );\n      }\n    }\n    throw new RequirementViolation(\n      multiLineString(\" \")(\n        `file ${path} is associated with EIP ${assetEipNum} but there`,\n        `are no changes being made to corresponding EIP itself. To assure`,\n        `that the change is authorized by the relevant stake-holders, you must`,\n        `also make changes to the EIP file itself for the asset changes to`,\n        `be eligible for auto-merge`\n      )\n    );\n  };\n\n  public attemptEditorApprovalGracefulTermination = async (\n    filename: string\n  ) => {\n    const editorApprovals = this.requireEIPEditors();\n    const approvals = await this.getApprovals();\n\n    const isEditorApproved =\n      _.intersection(editorApprovals, approvals).length >= 2;\n    if (isEditorApproved) {\n      throw new GracefulTermination(\n        multiLineString(\" \")(\n          `file ${filename} is not a valid filename, but this error has been`,\n          `ignored due to editor approvals`\n        )\n      );\n    }\n  };\n\n  attemptNewFileNoEIPNumber = async (path?: string) => {\n    if (!path) return;\n    const PR = await this.requirePr();\n\n    let isNewFile = await this.getParsedContent(path, PR.base.sha)\n      .then((res) => false)\n      .catch((err) => {\n        if (isFileNotFound(err)) {\n          return true;\n        }\n        throw err;\n      });\n\n    // if it's not a new file then the edgecase doesn't apply\n    if (!isNewFile) {\n      return;\n    }\n\n    const hasEIPNumber = EIP_NUM_RE.test(path);\n    // this edgecase is only relevant if the filename is not in expected format\n    if (hasEIPNumber) {\n      return;\n    }\n\n    // this only applies to files in the eips folder\n    const isInEIPSFolder = FILE_IN_EIP_FOLDER.test(path);\n    if (!isInEIPSFolder) {\n      return;\n    }\n\n    const editors = this.requireEIPEditors();\n\n    throw new RequirementViolation(\n      multiLineString(\" \")(\n        `file '${path}' is not a valid eip file name;`,\n        `all eip files need to be in eip-####.md format. It's assumed`,\n        `however that this has been included because an eip number`,\n        `has not been provided for this eip yet. cc ${editors.join(\",\")}`\n      )\n    );\n  };\n\n  /**\n   * Extracts the EIP number from a given filename (or returns null)\n   * @param filename EIP filename\n   */\n  requireFilenameEipNum = async (path: string) => {\n    const eipNumMatch = path.match(EIP_NUM_RE);\n    if (!eipNumMatch || eipNumMatch[1] === undefined) {\n      await this.attemptAssetGracefulTermination(path);\n      await this.attemptEditorApprovalGracefulTermination(path);\n      await this.attemptNewFileNoEIPNumber(path);\n      throw new RequirementViolation(\n        `'${path}' must be in eip-###.md format; this error will be overwritten upon relevant editor approval`\n      );\n    }\n    return eipNumMatch && parseInt(eipNumMatch[1]);\n  };\n}\n"]}